package worker

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net"
	"net/url"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/gobwas/ws"
	"github.com/gobwas/ws/wsutil"
	"github.com/zeromicro/go-zero/core/logx"
)

// ==================== WebSocket Message Types ====================

const (
	WSTypeAuth           = "AUTH"            // è®¤è¯è¯·æ±‚
	WSTypeAuthOK         = "AUTH_OK"         // è®¤è¯æˆåŠŸ
	WSTypeAuthFail       = "AUTH_FAIL"       // è®¤è¯å¤±è´¥
	WSTypePing           = "PING"            // å¿ƒè·³è¯·æ±‚
	WSTypePong           = "PONG"            // å¿ƒè·³å“åº”
	WSTypeLog            = "LOG"             // æ—¥å¿—æ¶ˆæ¯
	WSTypeLogBatch       = "LOG_BATCH"       // æ‰¹é‡æ—¥å¿—æ¶ˆæ¯
	WSTypeControl        = "CONTROL"         // æ§åˆ¶ä¿¡å·
	WSTypeTerminalOpen   = "TERMINAL_OPEN"   // æ‰“å¼€ç»ˆç«¯
	WSTypeTerminalClose  = "TERMINAL_CLOSE"  // å…³é—­ç»ˆç«¯
	WSTypeTerminalInput  = "TERMINAL_INPUT"  // ç»ˆç«¯è¾“å…¥
	WSTypeTerminalOutput = "TERMINAL_OUTPUT" // ç»ˆç«¯è¾“å‡º
	WSTypeTerminalResize = "TERMINAL_RESIZE" // ç»ˆç«¯å¤§å°è°ƒæ•´
	WSTypeFileList       = "FILE_LIST"       // æ–‡ä»¶åˆ—è¡¨
	WSTypeFileUpload     = "FILE_UPLOAD"     // æ–‡ä»¶ä¸Šä¼ 
	WSTypeFileDownload   = "FILE_DOWNLOAD"   // æ–‡ä»¶ä¸‹è½½
	WSTypeFileDelete     = "FILE_DELETE"     // æ–‡ä»¶åˆ é™¤
	WSTypeFileMkdir      = "FILE_MKDIR"      // åˆ›å»ºç›®å½•
	WSTypeWorkerInfo     = "WORKER_INFO"     // Workerä¿¡æ¯
)

// WSMessage WebSocketæ¶ˆæ¯ç»“æ„
type WSMessage struct {
	Type    string          `json:"type"`
	Payload json.RawMessage `json:"payload,omitempty"`
}

// WSAuthPayload è®¤è¯æ¶ˆæ¯è½½è·
type WSAuthPayload struct {
	WorkerName string `json:"workerName"`
	InstallKey string `json:"installKey"`
}

// WSLogPayload æ—¥å¿—æ¶ˆæ¯è½½è·
type WSLogPayload struct {
	TaskId    string `json:"taskId"`
	Level     string `json:"level"`
	Message   string `json:"message"`
	Timestamp int64  `json:"timestamp"`
}

// WSLogBatchPayload æ‰¹é‡æ—¥å¿—æ¶ˆæ¯è½½è·
type WSLogBatchPayload struct {
	Logs []WSLogPayload `json:"logs"`
}

// WSControlPayload æ§åˆ¶ä¿¡å·è½½è·
type WSControlPayload struct {
	TaskId string `json:"taskId"`
	Action string `json:"action"` // STOP, PAUSE, RESUME
}

// ==================== WebSocket Client ====================

// WSClientConfig WebSocketå®¢æˆ·ç«¯é…ç½?
type WSClientConfig struct {
	ServerURL       string        // WebSocketæœåŠ¡å™¨URL (e.g., ws://server:8888/api/v1/worker/ws)
	WorkerName      string        // Workeråç§°
	InstallKey      string        // å®‰è£…å¯†é’¥
	ReconnectDelay  time.Duration // åˆå§‹é‡è¿å»¶è¿Ÿ
	MaxReconnect    time.Duration // æœ€å¤§é‡è¿å»¶è¿?
	PingInterval    time.Duration // å¿ƒè·³é—´éš”
	WriteTimeout    time.Duration // å†™è¶…æ—?
	ReadTimeout     time.Duration // è¯»è¶…æ—?
	LogBatchSize    int           // æ—¥å¿—æ‰¹é‡å‘é€å¤§å°?
	LogFlushTimeout time.Duration // æ—¥å¿—åˆ·æ–°è¶…æ—¶
}

// DefaultWSClientConfig é»˜è®¤é…ç½®
func DefaultWSClientConfig(serverURL, workerName, installKey string) *WSClientConfig {
	return &WSClientConfig{
		ServerURL:       serverURL,
		WorkerName:      workerName,
		InstallKey:      installKey,
		ReconnectDelay:  1 * time.Second,
		MaxReconnect:    30 * time.Second,
		PingInterval:    30 * time.Second,
		WriteTimeout:    10 * time.Second,
		ReadTimeout:     90 * time.Second,
		LogBatchSize:    50,
		LogFlushTimeout: 1 * time.Second,
	}
}

// ControlHandler æ§åˆ¶ä¿¡å·å¤„ç†å‡½æ•°
type ControlHandler func(taskId, action string)

// WorkerInfoHandler Workerä¿¡æ¯è¯·æ±‚å¤„ç†å‡½æ•°
type WorkerInfoHandler func() *WorkerInfoPayload

// FileOperationHandler æ–‡ä»¶æ“ä½œå¤„ç†å‡½æ•°æ¥å£
type FileOperationHandler interface {
	ListDir(path string) ([]FileInfo, error)
	ReadFile(path string) ([]byte, error)
	WriteFile(path string, data []byte) error
	DeleteFile(path string) error
	MakeDir(path string) error
}

// TerminalOperationHandler ç»ˆç«¯æ“ä½œå¤„ç†å‡½æ•°æ¥å£
type TerminalOperationHandler interface {
	CreateSession(sessionId string) (*TerminalSession, error)
	CloseSession(sessionId string) error
	ExecuteCommand(ctx context.Context, sessionId, command string) error
	SendInput(sessionId string, data []byte) error
	ResizeTerminal(sessionId string, cols, rows int) error
	InterruptCommand(sessionId string) error
	IsCommandBlacklisted(command string) bool
}

// WorkerControlHandler Workerçº§åˆ«æ§åˆ¶å¤„ç†å‡½æ•°ç±»å‹
type WorkerControlHandler func(action string, param string)

// WorkerWSClient Worker WebSocketå®¢æˆ·ç«?
type WorkerWSClient struct {
	config               *WSClientConfig
	conn                 net.Conn
	connMu               sync.RWMutex
	connected            atomic.Bool
	authenticated        atomic.Bool
	closeChan            chan struct{}
	closeOnce            sync.Once
	sendChan             chan []byte
	logBuffer            []WSLogPayload
	logMu                sync.Mutex
	controlHandler       ControlHandler
	workerControlHandler WorkerControlHandler
	workerInfoHandler    WorkerInfoHandler
	fileHandler          FileOperationHandler
	terminalHandler      TerminalOperationHandler
	lastPong             time.Time
	pongMu               sync.RWMutex
	reconnecting         atomic.Bool
	wg                   sync.WaitGroup
}

// NewWorkerWSClient åˆ›å»ºWebSocketå®¢æˆ·ç«?
func NewWorkerWSClient(config *WSClientConfig) *WorkerWSClient {
	return &WorkerWSClient{
		config:    config,
		closeChan: make(chan struct{}),
		sendChan:  make(chan []byte, 256),
		logBuffer: make([]WSLogPayload, 0, config.LogBatchSize),
		lastPong:  time.Now(),
	}
}

// SetControlHandler è®¾ç½®æ§åˆ¶ä¿¡å·å¤„ç†å‡½æ•°
func (c *WorkerWSClient) SetControlHandler(handler ControlHandler) {
	c.controlHandler = handler
}

// SetWorkerControlHandler è®¾ç½®Workerçº§åˆ«æ§åˆ¶å¤„ç†å‡½æ•°
func (c *WorkerWSClient) SetWorkerControlHandler(handler WorkerControlHandler) {
	c.workerControlHandler = handler
}

// SetWorkerInfoHandler è®¾ç½®Workerä¿¡æ¯è¯·æ±‚å¤„ç†å‡½æ•°
func (c *WorkerWSClient) SetWorkerInfoHandler(handler WorkerInfoHandler) {
	c.workerInfoHandler = handler
}

// SetFileHandler è®¾ç½®æ–‡ä»¶æ“ä½œå¤„ç†å‡½æ•°
func (c *WorkerWSClient) SetFileHandler(handler FileOperationHandler) {
	c.fileHandler = handler
}

// SetTerminalHandler è®¾ç½®ç»ˆç«¯æ“ä½œå¤„ç†å‡½æ•°
func (c *WorkerWSClient) SetTerminalHandler(handler TerminalOperationHandler) {
	c.terminalHandler = handler
}

// IsConnected æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
func (c *WorkerWSClient) IsConnected() bool {
	return c.connected.Load() && c.authenticated.Load()
}

// Connect è¿æ¥åˆ°WebSocketæœåŠ¡å™?
func (c *WorkerWSClient) Connect(ctx context.Context) error {
	return c.connectWithRetry(ctx, false)
}

// connectWithRetry å¸¦é‡è¯•çš„è¿æ¥
func (c *WorkerWSClient) connectWithRetry(ctx context.Context, isReconnect bool) error {
	backoff := c.config.ReconnectDelay
	attempt := 0

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-c.closeChan:
			return fmt.Errorf("client closed")
		default:
		}

		err := c.doConnect(ctx)
		if err == nil {
			// è¿æ¥æˆåŠŸ
			if isReconnect {
				logx.Info("[WSClient] Reconnected to server"))
			} else {
				logx.Info("[WSClient] Connected to server"))
			}
			return nil
		}

		attempt++
		logx.Info("[WSClient] Connection attempt %d failed: %v, retrying in %v..."), attempt, err, backoff)

		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-c.closeChan:
			return fmt.Errorf("client closed")
		case <-time.After(backoff):
		}

		// æŒ‡æ•°é€€é?
		backoff = time.Duration(float64(backoff) * 2)
		if backoff > c.config.MaxReconnect {
			backoff = c.config.MaxReconnect
		}
	}
}

// doConnect æ‰§è¡Œå•æ¬¡è¿æ¥
func (c *WorkerWSClient) doConnect(ctx context.Context) error {
	// è§£æWebSocket URL
	wsURL := c.buildWSURL()

	// å»ºç«‹WebSocketè¿æ¥
	conn, _, _, err := ws.Dial(ctx, wsURL)
	if err != nil {
		return fmt.Errorf("dial failed: %w", err)
	}

	c.connMu.Lock()
	c.conn = conn
	c.connMu.Unlock()
	c.connected.Store(true)

	// å‘é€è®¤è¯æ¶ˆæ?
	if err := c.authenticate(); err != nil {
		c.conn.Close()
		c.connected.Store(false)
		return fmt.Errorf("authentication failed: %w", err)
	}

	c.authenticated.Store(true)
	c.pongMu.Lock()
	c.lastPong = time.Now()
	c.pongMu.Unlock()

	return nil
}

// buildWSURL æ„å»ºWebSocket URL
func (c *WorkerWSClient) buildWSURL() string {
	serverURL := c.config.ServerURL

	// å¦‚æœå·²ç»æ˜¯ws://æˆ–wss://å¼€å¤´ï¼Œç›´æ¥ä½¿ç”¨
	if strings.HasPrefix(serverURL, "ws://") || strings.HasPrefix(serverURL, "wss://") {
		return serverURL
	}

	// å°†http://è½¬æ¢ä¸ºws://ï¼Œhttps://è½¬æ¢ä¸ºwss://
	if strings.HasPrefix(serverURL, "https://") {
		serverURL = "wss://" + strings.TrimPrefix(serverURL, "https://")
	} else if strings.HasPrefix(serverURL, "http://") {
		serverURL = "ws://" + strings.TrimPrefix(serverURL, "http://")
	} else {
		serverURL = "ws://" + serverURL
	}

	// è§£æURLå¹¶æ·»åŠ è·¯å¾?
	u, err := url.Parse(serverURL)
	if err != nil {
		return serverURL + "/api/v1/worker/ws"
	}

	// å¦‚æœæ²¡æœ‰è·¯å¾„æˆ–è·¯å¾„ä¸º/ï¼Œæ·»åŠ WebSocketè·¯å¾„
	if u.Path == "" || u.Path == "/" {
		u.Path = "/api/v1/worker/ws"
	}

	return u.String()
}

// authenticate å‘é€è®¤è¯æ¶ˆæ¯å¹¶ç­‰å¾…å“åº”
func (c *WorkerWSClient) authenticate() error {
	// æ„å»ºè®¤è¯æ¶ˆæ¯
	authPayload := WSAuthPayload{
		WorkerName: c.config.WorkerName,
		InstallKey: c.config.InstallKey,
	}
	payloadData, _ := json.Marshal(authPayload)

	msg := WSMessage{
		Type:    WSTypeAuth,
		Payload: payloadData,
	}
	msgData, _ := json.Marshal(msg)

	// å‘é€è®¤è¯æ¶ˆæ?
	c.connMu.RLock()
	conn := c.conn
	c.connMu.RUnlock()

	if err := wsutil.WriteClientMessage(conn, ws.OpText, msgData); err != nil {
		return fmt.Errorf("send auth message failed: %w", err)
	}

	// ç­‰å¾…è®¤è¯å“åº”ï¼ˆè¶…æ—?0ç§’ï¼‰
	conn.SetReadDeadline(time.Now().Add(30 * time.Second))
	defer conn.SetReadDeadline(time.Time{})

	data, _, err := wsutil.ReadServerData(conn)
	if err != nil {
		return fmt.Errorf("read auth response failed: %w", err)
	}

	var respMsg WSMessage
	if err := json.Unmarshal(data, &respMsg); err != nil {
		return fmt.Errorf("parse auth response failed: %w", err)
	}

	switch respMsg.Type {
	case WSTypeAuthOK:
		return nil
	case WSTypeAuthFail:
		var reason struct {
			Reason string `json:"reason"`
		}
		json.Unmarshal(respMsg.Payload, &reason)
		return fmt.Errorf("auth rejected: %s", reason.Reason)
	default:
		return fmt.Errorf("unexpected response type: %s", respMsg.Type)
	}
}

// Start å¯åŠ¨å®¢æˆ·ç«¯ï¼ˆè¿æ¥å¹¶å¯åŠ¨è¯»å†™åç¨‹ï¼‰
func (c *WorkerWSClient) Start(ctx context.Context) error {
	// è¿æ¥æœåŠ¡å™?
	if err := c.Connect(ctx); err != nil {
		return err
	}

	// å¯åŠ¨è¯»å–åç¨‹
	c.wg.Add(1)
	go c.readPump(ctx)

	// å¯åŠ¨å†™å…¥åç¨‹
	c.wg.Add(1)
	go c.writePump(ctx)

	// å¯åŠ¨å¿ƒè·³åç¨‹
	c.wg.Add(1)
	go c.pingPump(ctx)

	// å¯åŠ¨æ—¥å¿—åˆ·æ–°åç¨‹
	c.wg.Add(1)
	go c.logFlushPump(ctx)

	return nil
}

// Close å…³é—­å®¢æˆ·ç«?
func (c *WorkerWSClient) Close() {
	c.closeOnce.Do(func() {
		close(c.closeChan)

		c.connMu.Lock()
		if c.conn != nil {
			c.conn.Close()
			c.conn = nil // ç¡®ä¿è®¾ä¸º nilï¼Œé˜²æ­¢å…¶ä»?goroutine ä½¿ç”¨å·²å…³é—­çš„è¿æ¥
		}
		c.connMu.Unlock()

		c.connected.Store(false)
		c.authenticated.Store(false)
	})

	// ç­‰å¾…æ‰€æœ‰åç¨‹é€€å‡?
	c.wg.Wait()
}


// ==================== Message Pumps ====================

// readPump è¯»å–æ¶ˆæ¯å¾ªç¯
func (c *WorkerWSClient) readPump(ctx context.Context) {
	defer c.wg.Done()

	for {
		select {
		case <-ctx.Done():
			return
		case <-c.closeChan:
			return
		default:
		}

		// ä½¿ç”¨è¯»é”ä¿æŠ¤æ•´ä¸ªè¯»å–æ“ä½œï¼Œé˜²æ­¢ç«æ€æ¡ä»?
		c.connMu.RLock()
		conn := c.conn
		if conn == nil {
			c.connMu.RUnlock()
			// è¿æ¥æ–­å¼€ï¼Œç­‰å¾…é‡è¿?
			time.Sleep(100 * time.Millisecond)
			continue
		}

		// è®¾ç½®è¯»å–è¶…æ—¶
		if err := conn.SetReadDeadline(time.Now().Add(c.config.ReadTimeout)); err != nil {
			c.connMu.RUnlock()
			// è¿æ¥å¯èƒ½å·²å…³é—­ï¼Œè§¦å‘é‡è¿
			if !c.handleReadError(ctx, err) {
				return
			}
			continue
		}

		data, _, err := wsutil.ReadServerData(conn)
		c.connMu.RUnlock()

		if err != nil {
			if !c.handleReadError(ctx, err) {
				return
			}
			continue
		}

		var msg WSMessage
		if err := json.Unmarshal(data, &msg); err != nil {
			logx.Info("[WSClient] Invalid message: %v"), err)
			continue
		}

		// è·¯ç”±æ¶ˆæ¯
		c.handleMessage(&msg)
	}
}

// handleReadError å¤„ç†è¯»å–é”™è¯¯
func (c *WorkerWSClient) handleReadError(ctx context.Context, err error) bool {
	select {
	case <-c.closeChan:
		return false
	default:
	}

	logx.Infof("[WSClient] Read error: %v", err)
	
	// å…³é—­æ—§è¿æ?
	c.connMu.Lock()
	if c.conn != nil {
		c.conn.Close()
		c.conn = nil
	}
	c.connMu.Unlock()
	
	c.connected.Store(false)
	c.authenticated.Store(false)

	// å°è¯•é‡è¿
	if !c.reconnecting.CompareAndSwap(false, true) {
		// å·²ç»åœ¨é‡è¿ä¸­ï¼Œç­‰å¾…é‡è¿å®Œæˆ?
		for c.reconnecting.Load() {
			select {
			case <-c.closeChan:
				return false
			case <-ctx.Done():
				return false
			case <-time.After(100 * time.Millisecond):
				// ç»§ç»­ç­‰å¾…é‡è¿å®Œæˆ
			}
		}
		return true
	}

	// ä½¿ç”¨ç‹¬ç«‹çš?context è¿›è¡Œé‡è¿ï¼Œé¿å…ç»§æ‰¿å·²å–æ¶ˆçš„çˆ¶ context
	reconnectCtx, reconnectCancel := context.WithCancel(context.Background())
	
	go func() {
		defer func() {
			reconnectCancel()
			c.reconnecting.Store(false)
		}()
		
		// ç›‘å¬å…³é—­ä¿¡å·
		go func() {
			select {
			case <-c.closeChan:
				reconnectCancel()
			case <-reconnectCtx.Done():
			}
		}()
		
		// ç­‰å¾…ä¸€å°æ®µæ—¶é—´å†é‡è¿ï¼Œé¿å…ç«‹å³é‡è¿
		select {
		case <-reconnectCtx.Done():
			return
		case <-time.After(time.Second):
		}
		
		if err := c.connectWithRetry(reconnectCtx, true); err != nil {
			logx.Info("[WSClient] Reconnect failed: %v"), err)
		}
	}()

	return true
}

// writePump å†™å…¥æ¶ˆæ¯å¾ªç¯
func (c *WorkerWSClient) writePump(ctx context.Context) {
	defer c.wg.Done()

	for {
		select {
		case <-ctx.Done():
			return
		case <-c.closeChan:
			return
		case data := <-c.sendChan:
			if !c.IsConnected() {
				// æœªè¿æ¥ï¼Œä¸¢å¼ƒæ¶ˆæ¯
				continue
			}

			// ä½¿ç”¨è¯»é”ä¿æŠ¤æ•´ä¸ªå†™å…¥æ“ä½œ
			c.connMu.RLock()
			conn := c.conn
			if conn == nil {
				c.connMu.RUnlock()
				continue
			}

			if err := conn.SetWriteDeadline(time.Now().Add(c.config.WriteTimeout)); err != nil {
				c.connMu.RUnlock()
				logx.Info("[WSClient] SetWriteDeadline error: %v"), err)
				c.connected.Store(false)
				continue
			}

			err := wsutil.WriteClientMessage(conn, ws.OpText, data)
			c.connMu.RUnlock()

			if err != nil {
				logx.Info("[WSClient] Write error: %v"), err)
				// è§¦å‘é‡è¿
				c.connected.Store(false)
			}
		}
	}
}

// pingPump å¿ƒè·³å¾ªç¯
func (c *WorkerWSClient) pingPump(ctx context.Context) {
	defer c.wg.Done()

	ticker := time.NewTicker(c.config.PingInterval)
	defer ticker.Stop()

	// å¿ƒè·³è¶…æ—¶é˜ˆå€¼ï¼š2å€å¿ƒè·³é—´éš?
	heartbeatTimeout := c.config.PingInterval * 2

	for {
		select {
		case <-ctx.Done():
			return
		case <-c.closeChan:
			return
		case <-ticker.C:
			if !c.IsConnected() {
				continue
			}

			// æ£€æŸ¥æ˜¯å¦è¶…æ—¶æœªæ”¶åˆ°PONG
			c.pongMu.RLock()
			lastPong := c.lastPong
			c.pongMu.RUnlock()

			if time.Since(lastPong) > heartbeatTimeout {
				logx.Info("[WSClient] Heartbeat timeout (no PONG for %v), triggering reconnect..."), time.Since(lastPong))
				
				// å…³é—­å½“å‰è¿æ¥å¹¶è§¦å‘é‡è¿?
				c.connMu.Lock()
				if c.conn != nil {
					c.conn.Close()
					c.conn = nil
				}
				c.connMu.Unlock()
				
				c.connected.Store(false)
				c.authenticated.Store(false)
				
				// è§¦å‘é‡è¿ï¼ˆå¦‚æœæ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„é‡è¿ï¼?
				if c.reconnecting.CompareAndSwap(false, true) {
					go func() {
						defer c.reconnecting.Store(false)
						
						// ä½¿ç”¨ç‹¬ç«‹çš?context è¿›è¡Œé‡è¿
						reconnectCtx, reconnectCancel := context.WithCancel(context.Background())
						defer reconnectCancel()
						
						// ç›‘å¬å…³é—­ä¿¡å·
						go func() {
							select {
							case <-c.closeChan:
								reconnectCancel()
							case <-reconnectCtx.Done():
							}
						}()
						
						time.Sleep(time.Second)
						if err := c.connectWithRetry(reconnectCtx, true); err != nil {
							logx.Info("[WSClient] Reconnect from pingPump failed: %v"), err)
						}
					}()
				}
				continue
			}

			// å‘é€PING
			c.sendMessage(&WSMessage{Type: WSTypePing})
		}
	}
}

// logFlushPump æ—¥å¿—åˆ·æ–°å¾ªç¯
func (c *WorkerWSClient) logFlushPump(ctx context.Context) {
	defer c.wg.Done()

	ticker := time.NewTicker(c.config.LogFlushTimeout)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			// é€€å‡ºå‰åˆ·æ–°å‰©ä½™æ—¥å¿—
			c.flushLogs()
			return
		case <-c.closeChan:
			c.flushLogs()
			return
		case <-ticker.C:
			c.flushLogs()
		}
	}
}

// ==================== Message Handling ====================

// handleMessage å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
func (c *WorkerWSClient) handleMessage(msg *WSMessage) {
	switch msg.Type {
	case WSTypeAuthOK:
		// è®¤è¯æˆåŠŸï¼ˆé‡è¿åå¯èƒ½æ”¶åˆ°ï¼?
		c.authenticated.Store(true)
		logx.Info("[WSClient] Authentication successful (reconnected)"))

	case WSTypeAuthFail:
		// è®¤è¯å¤±è´¥
		c.authenticated.Store(false)
		var reason struct {
			Reason string `json:"reason"`
		}
		json.Unmarshal(msg.Payload, &reason)
		logx.Info("[WSClient] Authentication failed: %s"), reason.Reason)

	case WSTypePing:
		// æ”¶åˆ°æœåŠ¡å™¨PINGï¼Œå›å¤PONG
		c.sendMessage(&WSMessage{Type: WSTypePong})
		c.pongMu.Lock()
		c.lastPong = time.Now()
		c.pongMu.Unlock()

	case WSTypePong:
		// æ”¶åˆ°æœåŠ¡å™¨PONG
		c.pongMu.Lock()
		c.lastPong = time.Now()
		c.pongMu.Unlock()

	case WSTypeControl:
		// æ”¶åˆ°æ§åˆ¶ä¿¡å·
		c.handleControl(msg.Payload)

	case WSTypeWorkerInfo:
		// æ”¶åˆ°Workerä¿¡æ¯è¯·æ±‚
		c.handleWorkerInfoRequest(msg.Payload)

	case WSTypeFileList:
		// æ”¶åˆ°æ–‡ä»¶åˆ—è¡¨è¯·æ±‚
		c.handleFileListRequest(msg.Payload)

	case WSTypeFileUpload:
		// æ”¶åˆ°æ–‡ä»¶ä¸Šä¼ è¯·æ±‚
		c.handleFileUploadRequest(msg.Payload)

	case WSTypeFileDownload:
		// æ”¶åˆ°æ–‡ä»¶ä¸‹è½½è¯·æ±‚
		c.handleFileDownloadRequest(msg.Payload)

	case WSTypeFileDelete:
		// æ”¶åˆ°æ–‡ä»¶åˆ é™¤è¯·æ±‚
		c.handleFileDeleteRequest(msg.Payload)

	case WSTypeFileMkdir:
		// æ”¶åˆ°åˆ›å»ºç›®å½•è¯·æ±‚
		c.handleFileMkdirRequest(msg.Payload)

	case WSTypeTerminalOpen:
		// æ”¶åˆ°æ‰“å¼€ç»ˆç«¯è¯·æ±‚
		c.handleTerminalOpenRequest(msg.Payload)

	case WSTypeTerminalClose:
		// æ”¶åˆ°å…³é—­ç»ˆç«¯è¯·æ±‚
		c.handleTerminalCloseRequest(msg.Payload)

	case WSTypeTerminalInput:
		// æ”¶åˆ°ç»ˆç«¯è¾“å…¥è¯·æ±‚
		c.handleTerminalInputRequest(msg.Payload)

	case WSTypeTerminalResize:
		// æ”¶åˆ°ç»ˆç«¯å¤§å°è°ƒæ•´è¯·æ±‚
		c.handleTerminalResizeRequest(msg.Payload)

	default:
		logx.Info("[WSClient] Unknown message type: %s"), msg.Type)
	}
}

// handleControl å¤„ç†æ§åˆ¶ä¿¡å·
func (c *WorkerWSClient) handleControl(payload json.RawMessage) {
	// å…ˆå°è¯•è§£æä¸º Worker çº§åˆ«æ§åˆ¶å‘½ä»¤
	var workerControl struct {
		Action      string `json:"action"`
		NewName     string `json:"newName,omitempty"`
		Concurrency int    `json:"concurrency,omitempty"`
	}
	if err := json.Unmarshal(payload, &workerControl); err == nil {
		logx.Infof("[WSClient] Parsed control action: '%s'", workerControl.Action)
		
		// æ£€æŸ¥æ˜¯å¦æ˜¯ Worker çº§åˆ«æ§åˆ¶å‘½ä»¤
		isWorkerControl := false
		switch workerControl.Action {
		case "WORKER_STOP":
			logx.Info("[WSClient] Executing WORKER_STOP command..."))
			if c.workerControlHandler != nil {
				c.workerControlHandler("stop", "")
			} else {
				logx.Info("[WSClient] ERROR: workerControlHandler is nil!"))
			}
			isWorkerControl = true
		case "WORKER_RESTART":
			logx.Info("[WSClient] Executing WORKER_RESTART command..."))
			if c.workerControlHandler != nil {
				c.workerControlHandler("restart", "")
			} else {
				logx.Info("[WSClient] ERROR: workerControlHandler is nil!"))
			}
			isWorkerControl = true
		case "WORKER_RENAME":
			logx.Info("[WSClient] Executing WORKER_RENAME command, new name: %s"), workerControl.NewName)
			if c.workerControlHandler != nil {
				c.workerControlHandler("rename", workerControl.NewName)
			}
			isWorkerControl = true
		case "WORKER_SET_CONCURRENCY":
			logx.Info("[WSClient] Executing WORKER_SET_CONCURRENCY command, concurrency: %d"), workerControl.Concurrency)
			if c.workerControlHandler != nil {
				c.workerControlHandler("setConcurrency", fmt.Sprintf("%d", workerControl.Concurrency))
			}
			isWorkerControl = true
		}
		
		if isWorkerControl {
			return
		}
	}

	// è§£æä¸ºä»»åŠ¡çº§åˆ«æ§åˆ¶å‘½ä»?
	var controlPayload WSControlPayload
	if err := json.Unmarshal(payload, &controlPayload); err != nil {
		logx.Info("[WSClient] Invalid control payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received task control signal: taskId=%s, action=%s"),
		controlPayload.TaskId, controlPayload.Action)

	if c.controlHandler != nil {
		c.controlHandler(controlPayload.TaskId, controlPayload.Action)
	}
}

// WSWorkerInfoRequest Workerä¿¡æ¯è¯·æ±‚è½½è·
type WSWorkerInfoRequest struct {
	RequestId string `json:"requestId"` // è¯·æ±‚IDï¼Œç”¨äºå…³è”å“åº?
}

// WSWorkerInfoResponse Workerä¿¡æ¯å“åº”è½½è·
type WSWorkerInfoResponse struct {
	RequestId string             `json:"requestId"`
	Info      *WorkerInfoPayload `json:"info"`
	Error     string             `json:"error,omitempty"`
}

// handleWorkerInfoRequest å¤„ç†Workerä¿¡æ¯è¯·æ±‚
func (c *WorkerWSClient) handleWorkerInfoRequest(payload json.RawMessage) {
	var request WSWorkerInfoRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid worker info request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received worker info request: requestId=%s"), request.RequestId)

	// æ„å»ºå“åº”
	response := WSWorkerInfoResponse{
		RequestId: request.RequestId,
	}

	if c.workerInfoHandler != nil {
		response.Info = c.workerInfoHandler()
	} else {
		response.Error = "worker info handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeWorkerInfo,
		Payload: payloadData,
	})
}

// ==================== Send Methods ====================

// sendMessage å‘é€æ¶ˆæ¯ï¼ˆå†…éƒ¨æ–¹æ³•ï¼?
func (c *WorkerWSClient) sendMessage(msg *WSMessage) error {
	data, err := json.Marshal(msg)
	if err != nil {
		return err
	}

	select {
	case c.sendChan <- data:
		return nil
	case <-c.closeChan:
		return fmt.Errorf("client closed")
	default:
		return fmt.Errorf("send buffer full")
	}
}

// SendLog å‘é€å•æ¡æ—¥å¿?
func (c *WorkerWSClient) SendLog(taskId, level, message string) error {
	log := WSLogPayload{
		TaskId:    taskId,
		Level:     level,
		Message:   message,
		Timestamp: time.Now().UnixMilli(),
	}

	c.logMu.Lock()
	c.logBuffer = append(c.logBuffer, log)
	shouldFlush := len(c.logBuffer) >= c.config.LogBatchSize
	c.logMu.Unlock()

	if shouldFlush {
		c.flushLogs()
	}

	return nil
}

// SendLogImmediate ç«‹å³å‘é€å•æ¡æ—¥å¿—ï¼ˆä¸ç¼“å†²ï¼‰
func (c *WorkerWSClient) SendLogImmediate(taskId, level, message string) error {
	if !c.IsConnected() {
		return fmt.Errorf("not connected")
	}

	payload := WSLogPayload{
		TaskId:    taskId,
		Level:     level,
		Message:   message,
		Timestamp: time.Now().UnixMilli(),
	}
	payloadData, _ := json.Marshal(payload)

	logx.Infof("[WSClient] SendLogImmediate: taskId=%s, level=%s, msg=%s", taskId, level, message)

	return c.sendMessage(&WSMessage{
		Type:    WSTypeLog,
		Payload: payloadData,
	})
}

// flushLogs åˆ·æ–°æ—¥å¿—ç¼“å†²åŒ?
func (c *WorkerWSClient) flushLogs() {
	c.logMu.Lock()
	if len(c.logBuffer) == 0 {
		c.logMu.Unlock()
		return
	}

	logs := c.logBuffer
	c.logBuffer = make([]WSLogPayload, 0, c.config.LogBatchSize)
	c.logMu.Unlock()

	if !c.IsConnected() {
		// æœªè¿æ¥ï¼Œè¾“å‡ºåˆ°æœ¬åœ°æ§åˆ¶å°
		logx.Infof("[WSClient] Not connected, flushing %d logs to console", len(logs))
		for _, log := range logs {
			logx.Infof("[%s] [%s] [Task:%s] %s",
				time.UnixMilli(log.Timestamp).Format("2006-01-02 15:04:05"),
				log.Level, log.TaskId, log.Message)
		}
		return
	}

	logx.Infof("[WSClient] Flushing %d logs to server", len(logs))

	// å‘é€æ‰¹é‡æ—¥å¿?
	if len(logs) == 1 {
		// å•æ¡æ—¥å¿—ç›´æ¥å‘é€?
		payloadData, _ := json.Marshal(logs[0])
		if err := c.sendMessage(&WSMessage{
			Type:    WSTypeLog,
			Payload: payloadData,
		}); err != nil {
			logx.Infof("[WSClient] Failed to send log: %v", err)
		}
	} else {
		// å¤šæ¡æ—¥å¿—æ‰¹é‡å‘é€?
		batchPayload := WSLogBatchPayload{Logs: logs}
		payloadData, _ := json.Marshal(batchPayload)
		if err := c.sendMessage(&WSMessage{
			Type:    WSTypeLogBatch,
			Payload: payloadData,
		}); err != nil {
			logx.Infof("[WSClient] Failed to send log batch: %v", err)
		}
	}
}

// ==================== Utility Methods ====================

// GetConn è·å–åº•å±‚è¿æ¥ï¼ˆç”¨äºæµ‹è¯•ï¼‰
func (c *WorkerWSClient) GetConn() net.Conn {
	c.connMu.RLock()
	defer c.connMu.RUnlock()
	return c.conn
}

// WaitForConnection ç­‰å¾…è¿æ¥å»ºç«‹
func (c *WorkerWSClient) WaitForConnection(timeout time.Duration) bool {
	deadline := time.Now().Add(timeout)
	for time.Now().Before(deadline) {
		if c.IsConnected() {
			return true
		}
		time.Sleep(100 * time.Millisecond)
	}
	return false
}


// ==================== File Operation Handlers ====================

// handleFileListRequest å¤„ç†æ–‡ä»¶åˆ—è¡¨è¯·æ±‚
func (c *WorkerWSClient) handleFileListRequest(payload json.RawMessage) {
	var request FileListRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid file list request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received file list request: requestId=%s, path=%s"), request.RequestId, request.Path)

	// æ„å»ºå“åº”
	response := FileListResponse{
		RequestId: request.RequestId,
		Path:      request.Path,
	}

	if c.fileHandler != nil {
		files, err := c.fileHandler.ListDir(request.Path)
		if err != nil {
			response.Error = err.Error()
		} else {
			response.Files = files
		}
	} else {
		response.Error = "file handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeFileList,
		Payload: payloadData,
	})
}

// handleFileUploadRequest å¤„ç†æ–‡ä»¶ä¸Šä¼ è¯·æ±‚
func (c *WorkerWSClient) handleFileUploadRequest(payload json.RawMessage) {
	var request FileUploadRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid file upload request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received file upload request: requestId=%s, path=%s"), request.RequestId, request.Path)

	// æ„å»ºå“åº”
	response := FileUploadResponse{
		RequestId: request.RequestId,
		Path:      request.Path,
	}

	if c.fileHandler != nil {
		// è§£ç Base64æ•°æ®
		data, err := base64.StdEncoding.DecodeString(request.Data)
		if err != nil {
			response.Error = "invalid base64 data: " + err.Error()
		} else {
			err = c.fileHandler.WriteFile(request.Path, data)
			if err != nil {
				response.Error = err.Error()
			} else {
				response.Success = true
			}
		}
	} else {
		response.Error = "file handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeFileUpload,
		Payload: payloadData,
	})
}

// handleFileDownloadRequest å¤„ç†æ–‡ä»¶ä¸‹è½½è¯·æ±‚
func (c *WorkerWSClient) handleFileDownloadRequest(payload json.RawMessage) {
	var request FileDownloadRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid file download request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received file download request: requestId=%s, path=%s"), request.RequestId, request.Path)

	// æ„å»ºå“åº”
	response := FileDownloadResponse{
		RequestId: request.RequestId,
		Path:      request.Path,
	}

	if c.fileHandler != nil {
		data, err := c.fileHandler.ReadFile(request.Path)
		if err != nil {
			response.Error = err.Error()
		} else {
			response.Data = base64.StdEncoding.EncodeToString(data)
			response.Size = int64(len(data))
		}
	} else {
		response.Error = "file handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeFileDownload,
		Payload: payloadData,
	})
}

// handleFileDeleteRequest å¤„ç†æ–‡ä»¶åˆ é™¤è¯·æ±‚
func (c *WorkerWSClient) handleFileDeleteRequest(payload json.RawMessage) {
	var request FileDeleteRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid file delete request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received file delete request: requestId=%s, path=%s"), request.RequestId, request.Path)

	// æ„å»ºå“åº”
	response := FileDeleteResponse{
		RequestId: request.RequestId,
		Path:      request.Path,
	}

	if c.fileHandler != nil {
		err := c.fileHandler.DeleteFile(request.Path)
		if err != nil {
			response.Error = err.Error()
		} else {
			response.Success = true
		}
	} else {
		response.Error = "file handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeFileDelete,
		Payload: payloadData,
	})
}

// handleFileMkdirRequest å¤„ç†åˆ›å»ºç›®å½•è¯·æ±‚
func (c *WorkerWSClient) handleFileMkdirRequest(payload json.RawMessage) {
	var request FileMkdirRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid file mkdir request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received file mkdir request: requestId=%s, path=%s"), request.RequestId, request.Path)

	// æ„å»ºå“åº”
	response := FileMkdirResponse{
		RequestId: request.RequestId,
		Path:      request.Path,
	}

	if c.fileHandler != nil {
		err := c.fileHandler.MakeDir(request.Path)
		if err != nil {
			response.Error = err.Error()
		} else {
			response.Success = true
		}
	} else {
		response.Error = "file handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeFileMkdir,
		Payload: payloadData,
	})
}


// ==================== Terminal Operation Handlers ====================

// handleTerminalOpenRequest å¤„ç†æ‰“å¼€ç»ˆç«¯è¯·æ±‚
func (c *WorkerWSClient) handleTerminalOpenRequest(payload json.RawMessage) {
	var request TerminalOpenRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid terminal open request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received terminal open request: requestId=%s, sessionId=%s"), request.RequestId, request.SessionId)

	// æ„å»ºå“åº”
	response := TerminalOpenResponse{
		RequestId: request.RequestId,
		SessionId: request.SessionId,
	}

	if c.terminalHandler != nil {
		session, err := c.terminalHandler.CreateSession(request.SessionId)
		if err != nil {
			response.Error = err.Error()
		} else {
			response.Success = true
			// å¦‚æœæŒ‡å®šäº†ç»ˆç«¯å¤§å°ï¼Œè®¾ç½®å®?
			if request.Cols > 0 && request.Rows > 0 {
				c.terminalHandler.ResizeTerminal(session.ID, request.Cols, request.Rows)
			}
		}
	} else {
		response.Error = "terminal handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeTerminalOpen,
		Payload: payloadData,
	})
}

// handleTerminalCloseRequest å¤„ç†å…³é—­ç»ˆç«¯è¯·æ±‚
func (c *WorkerWSClient) handleTerminalCloseRequest(payload json.RawMessage) {
	var request TerminalCloseRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid terminal close request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received terminal close request: requestId=%s, sessionId=%s"), request.RequestId, request.SessionId)

	// æ„å»ºå“åº”
	response := TerminalCloseResponse{
		RequestId: request.RequestId,
		SessionId: request.SessionId,
	}

	if c.terminalHandler != nil {
		err := c.terminalHandler.CloseSession(request.SessionId)
		if err != nil {
			response.Error = err.Error()
		} else {
			response.Success = true
		}
	} else {
		response.Error = "terminal handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeTerminalClose,
		Payload: payloadData,
	})
}

// handleTerminalInputRequest å¤„ç†ç»ˆç«¯è¾“å…¥è¯·æ±‚
func (c *WorkerWSClient) handleTerminalInputRequest(payload json.RawMessage) {
	var request TerminalInputRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid terminal input request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received terminal input request: requestId=%s, sessionId=%s"), request.RequestId, request.SessionId)

	// æ„å»ºå“åº”
	response := TerminalInputResponse{
		RequestId: request.RequestId,
		SessionId: request.SessionId,
	}

	if c.terminalHandler != nil {
		// å¦‚æœæœ‰ç›´æ¥å‘½ä»¤ï¼Œæ‰§è¡Œå‘½ä»¤
		if request.Command != "" {
			// æ£€æŸ¥å‘½ä»¤æ˜¯å¦åœ¨é»‘åå•ä¸­
			if c.terminalHandler.IsCommandBlacklisted(request.Command) {
				response.Error = "command is blacklisted"
			} else {
				err := c.terminalHandler.ExecuteCommand(context.Background(), request.SessionId, request.Command)
				if err != nil {
					response.Error = err.Error()
				} else {
					response.Success = true
				}
			}
		} else if request.Data != "" {
			// è§£ç Base64æ•°æ®å¹¶å‘é€åˆ°stdin
			data, err := DecodeTerminalInput(request.Data)
			if err != nil {
				response.Error = "invalid base64 data: " + err.Error()
			} else {
				// æ£€æŸ¥æ˜¯å¦æ˜¯Ctrl+C (0x03)
				if len(data) == 1 && data[0] == 0x03 {
					err = c.terminalHandler.InterruptCommand(request.SessionId)
				} else {
					err = c.terminalHandler.SendInput(request.SessionId, data)
				}
				if err != nil {
					response.Error = err.Error()
				} else {
					response.Success = true
				}
			}
		} else {
			response.Error = "no command or data provided"
		}
	} else {
		response.Error = "terminal handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeTerminalInput,
		Payload: payloadData,
	})
}

// handleTerminalResizeRequest å¤„ç†ç»ˆç«¯å¤§å°è°ƒæ•´è¯·æ±‚
func (c *WorkerWSClient) handleTerminalResizeRequest(payload json.RawMessage) {
	var request TerminalResizeRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		logx.Info("[WSClient] Invalid terminal resize request payload: %v"), err)
		return
	}

	logx.Info("[WSClient] Received terminal resize request: requestId=%s, sessionId=%s, cols=%d, rows=%d"),
		request.RequestId, request.SessionId, request.Cols, request.Rows)

	// æ„å»ºå“åº”
	response := TerminalResizeResponse{
		RequestId: request.RequestId,
		SessionId: request.SessionId,
	}

	if c.terminalHandler != nil {
		err := c.terminalHandler.ResizeTerminal(request.SessionId, request.Cols, request.Rows)
		if err != nil {
			response.Error = err.Error()
		} else {
			response.Success = true
		}
	} else {
		response.Error = "terminal handler not set"
	}

	// å‘é€å“åº?
	payloadData, _ := json.Marshal(response)
	c.sendMessage(&WSMessage{
		Type:    WSTypeTerminalResize,
		Payload: payloadData,
	})
}

// SendTerminalOutput å‘é€ç»ˆç«¯è¾“å‡?
func (c *WorkerWSClient) SendTerminalOutput(sessionId string, data []byte) error {
	if !c.IsConnected() {
		return fmt.Errorf("not connected")
	}

	payload := TerminalOutputPayload{
		SessionId: sessionId,
		Data:      EncodeTerminalOutput(data),
	}
	payloadData, _ := json.Marshal(payload)

	return c.sendMessage(&WSMessage{
		Type:    WSTypeTerminalOutput,
		Payload: payloadData,
	})
}

